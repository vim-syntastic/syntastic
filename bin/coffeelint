#!/usr/bin/env node

/*
CoffeeLint

Copyright (c) 2011 Matthew Perpick.
CoffeeLint is freely distributable under the MIT license.
*/

(function() {
  var CSVReporter, ErrorReport, Reporter, ReporterClass, coffeelint, config, configPath, errorReport, findCoffeeScripts, fs, glob, lint, optimist, options, path, paths, read, reporter, scripts, thisdir,
    __slice = Array.prototype.slice,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  path = require("path");

  fs = require("fs");

  glob = require("glob");

  optimist = require("optimist");

  thisdir = path.dirname(fs.realpathSync(__filename));

  coffeelint = require(path.join(thisdir, "..", "lib", "coffeelint"));

  read = function(path) {
    var realPath;
    realPath = fs.realpathSync(path);
    return fs.readFileSync(realPath).toString();
  };

  findCoffeeScripts = function(paths) {
    var files, p, _i, _len;
    files = [];
    for (_i = 0, _len = paths.length; _i < _len; _i++) {
      p = paths[_i];
      if (fs.statSync(p).isDirectory()) {
        files = files.concat(glob.sync(path.join(p, "**", "*.coffee")));
      } else {
        files.push(p);
      }
    }
    return files;
  };

  ErrorReport = (function() {

    function ErrorReport() {
      this.paths = {};
    }

    ErrorReport.prototype.getExitCode = function() {
      var path;
      for (path in this.paths) {
        if (this.pathHasError(path)) return 1;
      }
      return 0;
    };

    ErrorReport.prototype.getSummary = function() {
      var error, errorCount, errors, path, pathCount, warningCount, _i, _len, _ref;
      pathCount = errorCount = warningCount = 0;
      _ref = this.paths;
      for (path in _ref) {
        errors = _ref[path];
        pathCount++;
        for (_i = 0, _len = errors.length; _i < _len; _i++) {
          error = errors[_i];
          if (error.level === 'error') errorCount++;
          if (error.level === 'warn') warningCount++;
        }
      }
      return {
        errorCount: errorCount,
        warningCount: warningCount,
        pathCount: pathCount
      };
    };

    ErrorReport.prototype.getErrors = function(path) {
      return this.paths[path];
    };

    ErrorReport.prototype.pathHasWarning = function(path) {
      return this._hasLevel(path, 'warn');
    };

    ErrorReport.prototype.pathHasError = function(path) {
      return this._hasLevel(path, 'error');
    };

    ErrorReport.prototype._hasLevel = function(path, level) {
      var error, _i, _len, _ref;
      _ref = this.paths[path];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        error = _ref[_i];
        if (error.level === level) return true;
      }
      return false;
    };

    return ErrorReport;

  })();

  Reporter = (function() {

    function Reporter(errorReport) {
      this.errorReport = errorReport;
      this.ok = '✓';
      this.warn = '⚡';
      this.err = '✗';
    }

    Reporter.prototype.stylize = function() {
      var map, message, styles;
      message = arguments[0], styles = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      map = {
        bold: [1, 22],
        yellow: [33, 39],
        green: [32, 39],
        red: [31, 39]
      };
      return styles.reduce(function(m, s) {
        return "\u001b[" + map[s][0] + "m" + m + "\u001b[" + map[s][1] + "m";
      }, message);
    };

    Reporter.prototype.publish = function() {
      var errors, path, summary, _ref;
      this.print("");
      _ref = this.errorReport.paths;
      for (path in _ref) {
        errors = _ref[path];
        this.reportPath(path, errors);
      }
      summary = this.errorReport.getSummary();
      this.reportSummary(summary);
      this.print("");
      return this;
    };

    Reporter.prototype.reportSummary = function(s) {
      var e, err, file, msg, p, start, w, warn;
      start = s.errorCount > 0 ? "" + this.err + " " + (this.stylize("Lint!", 'red', 'bold')) : s.warningCount > 0 ? "" + this.warn + " " + (this.stylize("Warning!", 'yellow', 'bold')) : "" + this.ok + " " + (this.stylize("Ok!", 'green', 'bold'));
      e = s.errorCount;
      w = s.warningCount;
      p = s.pathCount;
      err = this.plural('error', e);
      warn = this.plural('warning', w);
      file = this.plural('file', p);
      msg = "" + start + " » " + e + " " + err + " and " + w + " " + warn + " in " + p + " " + file;
      return this.print("\n" + this.stylize(msg));
    };

    Reporter.prototype.reportPath = function(path, errors) {
      var color, e, msg, o, overall, _i, _len, _ref, _results;
      _ref = this.errorReport.pathHasError(path) ? [this.err, 'red'] : this.errorReport.pathHasWarning(path) ? [this.warn, 'yellow'] : [this.ok, 'green'], overall = _ref[0], color = _ref[1];
      this.print("  " + overall + " " + (this.stylize(path, color, 'bold')));
      _results = [];
      for (_i = 0, _len = errors.length; _i < _len; _i++) {
        e = errors[_i];
        o = e.level === 'error' ? this.err : this.warn;
        msg = "     " + ("" + o + " " + (this.stylize("#" + e.lineNumber, color)) + ": " + e.message + ".");
        if (e.context) msg += " " + e.context + ".";
        _results.push(this.print(msg));
      }
      return _results;
    };

    Reporter.prototype.print = function(message) {
      return console.log(message);
    };

    Reporter.prototype.plural = function(str, count) {
      if (count === 1) {
        return str;
      } else {
        return "" + str + "s";
      }
    };

    return Reporter;

  })();

  CSVReporter = (function(_super) {

    __extends(CSVReporter, _super);

    function CSVReporter() {
      CSVReporter.__super__.constructor.apply(this, arguments);
    }

    CSVReporter.prototype.publish = function() {
      var e, errors, f, path, _ref, _results;
      _ref = this.errorReport.paths;
      _results = [];
      for (path in _ref) {
        errors = _ref[path];
        _results.push((function() {
          var _i, _len, _results2;
          _results2 = [];
          for (_i = 0, _len = errors.length; _i < _len; _i++) {
            e = errors[_i];
            f = [path, e.lineNumber, e.level, e.message];
            _results2.push(this.print(f.join(",")));
          }
          return _results2;
        }).call(this));
      }
      return _results;
    };

    return CSVReporter;

  })(Reporter);

  lint = function(paths, config) {
    var errorReport;
    errorReport = new ErrorReport();
    paths.forEach(function(path) {
      var errors, source;
      source = read(path);
      errors = coffeelint.lint(source, config);
      return errorReport.paths[path] = errors;
    });
    return errorReport;
  };

  options = optimist.usage("Usage: coffeelint [options] source [...]").alias("f", "file").alias("h", "help").alias("v", "version").describe("f", "Specify a custom configuration file.").describe("h", "Print help information.").describe("v", "Print current version number.").describe("r", "Recursively lint .coffee files in subdirectories.").describe("csv", "Use the csv reporter.").boolean("csv").boolean("r");

  if (options.argv.v) {
    console.log(coffeelint.VERSION);
    process.exit(0);
  } else if (options.argv.h) {
    options.showHelp();
    process.exit(0);
  } else if (options.argv._.length < 1) {
    options.showHelp();
    process.exit(1);
  } else {
    paths = options.argv._;
    scripts = options.argv.r ? findCoffeeScripts(paths) : paths;
    configPath = options.argv.f;
    config = configPath ? JSON.parse(read(configPath)) : {};
    errorReport = lint(scripts, config);
    ReporterClass = options.argv.csv ? CSVReporter : Reporter;
    reporter = new ReporterClass(errorReport);
    reporter.publish();
    process.exit(errorReport.getExitCode());
  }

}).call(this);
